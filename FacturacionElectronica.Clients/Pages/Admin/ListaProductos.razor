@page "/admin/productos"
@layout AdminLayout

@using FacturacionElectronica.Clients.DTOs
@using FacturacionElectronica.Clients.Services
@inject ProductoApiService ApiService
@inject NavigationManager Navigation

<!-- Reutilizamos tu clase .nav-card que ya tiene el efecto glassmorphism perfecto -->
<div class="nav-card">
    <div class="form-card-header">
        <h3>
            <span class="oi oi-list-rich"></span>
            Stock de Productos y Lotes
        </h3>
    </div>

    <div class="p-4">
        @if (selectedProduct == null)
        {
            <!-- VISTA 1: TABLA DE PRODUCTOS Y FILTROS -->
            <!-- SECCIÓN DE FILTROS (CORREGIDA) -->
            <div class="filter-controls">
                <!-- Filtro por Nombre -->
                <div class="flex-grow-1">
                    <!-- Se elimina @oninput y se usa @bind:event="oninput" para que se actualice mientras escribes -->
                    <input type="text" class="filter-control" placeholder="Filtrar por nombre..."
                           @bind="NameFilter" @bind:event="oninput" />
                </div>
                <!-- Filtro por Categoría -->
                <div class="flex-grow-1">
                    <!-- Se elimina el @onchange conflictivo -->
                    <select class="filter-control" @bind="CategoryFilter">
                        <option value="">Todas las categorías</option>
                        @foreach (var category in uniqueCategories)
                        {
                            <option value="@category">@category</option>
                        }
                    </select>
                </div>
            </div>

            <div class="table-responsive">
                <table class="table-theme">
                    <thead>
                        <tr>
                            <th>Nombre</th>
                            <th>Tipo (Categoría)</th>
                            <th>Estado</th>
                        </tr>
                    </thead>
                    <tbody>
                        @foreach (var producto in filteredProducts)
                        {
                            <tr @onclick="() => SelectProduct(producto)" style="cursor: pointer;">
                                <td>@producto.Nombre</td>
                                <td>@producto.TipoProducto</td>
                                <td>
                                    <span class="badge fs-6 @(producto.Activo ? "text-bg-success" : "text-bg-secondary")">
                                        @(producto.Activo ? "Activo" : "Inactivo")
                                    </span>
                                </td>
                            </tr>
                        }
                    </tbody>
                </table>
            </div>
        }
        else
        {
            <!-- VISTA 2: DETALLE DEL PRODUCTO SELECCIONADO -->
            <p class="text-muted-white mb-4">
                Viendo los detalles de <strong>@selectedProduct.Nombre</strong>.
            </p>
            <div class="card-body p-0">
                @if (selectedProduct.Lotes.Any())
                {
                    <h5 class="mb-3">Lotes Registrados</h5>
                    <div class="table-responsive">
                        <table class="table-theme">
                            <thead>
                                <tr>
                                    <th>Fecha Compra</th>
                                    <th>Fecha Expiración</th>
                                    <th>Costo Unit.</th>
                                    <th>Precio Venta</th>
                                    <th>Cant. Comprada</th>
                                    <th>Cant. Disponible</th>
                                </tr>
                            </thead>
                            <tbody>
                                @foreach (var lote in selectedProduct.Lotes)
                                {
                                    <tr>
                                        <td>@lote.FechaCompra.ToString("yyyy-MM-dd")</td>
                                        <td>@lote.FechaExpiracion?.ToString("yyyy-MM-dd")</td>
                                        <td>@lote.CostoUnitario.ToString("C")</td>
                                        <td>@lote.PrecioVentaUnitario.ToString("C")</td>
                                        <td>@lote.CantidadComprada</td>
                                        <td>@lote.CantidadDisponible</td>
                                    </tr>
                                }
                            </tbody>
                        </table>
                    </div>
                }
                else
                {
                    <div class="alert alert-info text-center"><em>Este producto no tiene lotes registrados.</em></div>
                }
            </div>
            <div class="form-actions">
                <button class="btn btn-primary" @onclick="CloseDetailsView">
                    <span class="oi oi-check" aria-hidden="true"></span> Aceptar y Volver
                </button>
            </div>
        }

        @if (isLoading)
        {
            <p class="text-center"><em>Cargando lista de productos...</em></p>
        }
        else if (!string.IsNullOrEmpty(errorMessage))
        {
            <div class="alert alert-danger">@errorMessage</div>
        }
    </div>
</div>

@code {
    private List<ProductWithLotesDto> allProducts = new();
    private List<ProductWithLotesDto> filteredProducts = new();
    private List<string> uniqueCategories = new();
    private bool isLoading = true;
    private string? errorMessage;
    private ProductWithLotesDto? selectedProduct;

    // ==================================================
    // === CAMBIOS EN LA LÓGICA DE FILTRADO ===
    // ==================================================

    // 1. Se crea un "backing field" para el filtro de nombre
    private string _nameFilter = string.Empty;
    // 2. Se convierte en una propiedad. El @bind ahora apunta a "NameFilter"
    private string NameFilter
    {
        get => _nameFilter;
        set
        {
            _nameFilter = value;
            ApplyFilters(); // Se llama al método de filtrado automáticamente
        }
    }

    // 3. Se crea un "backing field" para el filtro de categoría
    private string _categoryFilter = string.Empty;
    // 4. Se convierte en una propiedad. El @bind ahora apunta a "CategoryFilter"
    private string CategoryFilter
    {
        get => _categoryFilter;
        set
        {
            _categoryFilter = value;
            ApplyFilters(); // Se llama al método de filtrado automáticamente
        }
    }

    protected override async Task OnInitializedAsync() => await LoadProducts();

    private async Task LoadProducts()
    {
        isLoading = true;
        errorMessage = null;
        try
        {
            allProducts = await ApiService.GetProductosConLotesAsync();
            uniqueCategories = allProducts.Select(p => p.TipoProducto).Distinct().OrderBy(c => c).ToList();
            ApplyFilters();
        }
        catch (Exception ex)
        {
            errorMessage = $"Error al cargar los productos: {ex.Message}.";
        }
        finally
        {
            isLoading = false;
        }
    }

    private void ApplyFilters()
    {
        var query = allProducts.AsEnumerable();

        // La lógica ahora usa las propiedades privadas (_nameFilter, _categoryFilter)
        if (!string.IsNullOrWhiteSpace(_nameFilter))
        {
            query = query.Where(p => p.Nombre.Contains(_nameFilter, StringComparison.OrdinalIgnoreCase));
        }

        if (!string.IsNullOrWhiteSpace(_categoryFilter))
        {
            query = query.Where(p => p.TipoProducto == _categoryFilter);
        }

        filteredProducts = query.ToList();
    }

    private void SelectProduct(ProductWithLotesDto product) => selectedProduct = product;
    private void CloseDetailsView() => selectedProduct = null;
}
